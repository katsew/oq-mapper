// Functions ------------------------------
{
	var flatten = function (arr) {
    if (arr == null) { return null; }
    return arr.reduce(function(a, b) {
      return Array.isArray(b) ? a.concat(flatten(b)) : a.concat(b);
    }, []).filter(function(item) {
      return !Array.isArray(item) && item != null && item !== "\n";
    });
  };
  
  var parseTagInComment = function(comment) {
    var matches = comment.match(/`(.*)`/g);
    var meta = matches != null ? matches.map(function(item) {
      return item.replace(/`/g, "")
        .replace(/'/g, "")
        .replace(/\\n/g, " ")
        .split(" ")
        .filter(function(item) {
          return item.length > 0;
        })
        .map(function(item) {
          var splitted = item.split(":");
          var obj = {};
          obj[splitted[0]] = splitted[1];
          return obj;
        });
    }) : [];
    return flatten(meta);
  }
  var genNumberType = function (type, length, sign) {
    var numberType = {
      type: type.toLowerCase(),
      sign: sign,
      length: length,
      min: 0,
      max: 0,
      bites: 0
    };
    switch (numberType.type) {
      case "int":
        numberType.min = sign === "unsigned" ? 0 : -2147483648;
        numberType.max = sign === "unsigned" ? 4294967295 : 2147483647;
        numberType.bites = 4;
        break;
      case "tinyint":
        numberType.min = sign === "unsigned" ? 0 : -128;
        numberType.max = sign === "unsigned" ? 255 : 127;
        numberType.bites = 1;
        break;
    }
    return numberType;
  }

  var genStringType = function (type, length) {
    var stringType = {
      type: type.toLowerCase(),
      length: length
    }
    switch (stringType) {
      case "varchar":
        stringType.length = 255
        break;
    }
    return stringType;
  }
    
  var currentTimeStamp = function() {
    var date = new Date();
    var year = date.getFullYear();
    var month = ("00" + date.getMonth()).slice(-2);
    var day = ("00" + date.getDay()).slice(-2);
    var hours = ("00" + date.getHours()).slice(-2);
    var minutes = ("00" + date.getMinutes()).slice(-2);
    var seconds = ("00" + date.getSeconds()).slice(-2);
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  }
  
  var flattenParams = function(head, tail) {
    var rest = tail.map(function(item) {
	  return item[item.length - 1];
    });
    return [head, ...rest];
  }
  
  var genIndex = function(key, head, tail, isUnique) {
    var keys = flattenParams(head, tail);
    var index = {
      type: "index",
      name: key,
      keys: keys,
      unique: isUnique
    };
    return index;
  }
}


// Start ------------------------------
Start
  = __ queries:Queries __ {
    return queries;
  }
  
// Queries ------------------------------
Queries
  = body: SourceElements? {
  	return flatten(body);
  }
  
// SourceElements ------------------------------
SourceElements
  = SourceElement (__ SourceElement)*
  
SourceElement
  = Statement
  
// Statements ------------------------------

Statement
  = 
  CommentOut
  / SetStatement
  / CreateStatement
  / CreateTableStatement
  / AlterStatement
  / DropStatement
  / TruncateStatement
  / TransactionStatement
  / UseStatement
  / DelimiterStatement

SetStatement = SetToken _ any  { return null; }
CreateStatement
  = 
      (
  	    CreateToken _ SchemaToken _ any EOS
      ) { return null; }
      /
      (
        CreateToken _ DefinerToken _ "=" _ any _ TriggerToken _ TableName _ (
          AfterToken _ InsertToken _ OnToken
        ) { return null; }
      )
      
CreateTableStatement
  =  CreateToken _ TableToken _ (
    IfToken _ NotToken _ ExistsToken
    /
    IfToken _ ExistsToken
    /
    ""
  ) _ schema:TableName _ wl
    __ elements:Elements __
  wr __ EngineToken _ "=" _ engines _ ( AutoIncrementToken "=" integer / "" ) _ ( DefaultToken _ CharsetToken "=" charsets / "")
  EOS {
    var fields = elements.filter(function(element) {
      return element.type !== "pk" && element.type !== "constraint" && element.type !== "index";
    });
    var primaryKey = elements.filter(function(element){
      return element.type === "pk";
    });
    var foreignKey = elements.filter(function(element) {
      var type = element.type;
      type === "constraint" && delete element.type; // Be careful with side effects!
      return type === "constraint";
    });
    var index = elements.filter(function(element) {
      var type = element.type;
      type === "index" && delete element.type; // Be careful with side effects!
      return type === "index";
    });
    if (primaryKey.length > 1) { throw new Error("Primary key must be only 1."); }
    var mapped = Object.assign({}, schema, {
      pk: primaryKey[0]["keys"],
      fields: fields,
      constraint: foreignKey,
      index: index
    });
    console.log("Result:", mapped);
    return mapped;
  }

AlterStatement = AlterToken any { return null; }
DropStatement = DropToken any  { return null; }
TruncateStatement = TruncateToken any  { return null; }
TransactionStatement = StartToken TransactionToken CommitToken EOS  { return null; }
UseStatement = UseToken any  { return null; }
DelimiterStatement = DelimiterToken any  { return null; }

// Combinations

//// Comment
Comment "comment" = CommentToken _ comment:anyCharacter {
  var replaced = comment.replace(/'/g, "").replace(/"/g, "'");
  var tag = parseTagInComment(replaced);
  console.log("Comment", replaced, tag);
  return {
   comment: replaced,
   tags: tag
 };
}

//// Column
Elements = (
  Constraint
  /
  Key
  /
  PrimaryKey
  /
  UniqueIndex
  /
  Index
  /
  ( NullColumn / AutoIncrementColumn / Column / NotNullColumn )
)+

Column = _ fieldName:ObjectName _ type:Type _ NotToken _ NullToken _ DefaultToken _ defaultVal:defaultValue _ meta:( Comment / "" ) _ ( "," / "" ) __ {
  var column = Object.assign({
    name: fieldName,
    default: defaultVal,
    autoIncrement: true,
  }, type, meta);
  return column;
}

AutoIncrementColumn = _ fieldName:ObjectName _ type:Type _ NotToken _ NullToken _ AutoIncrementToken _ meta:( Comment / "" ) _ ( "," / "" ) __ {
  var column = Object.assign({
    name: fieldName,
    default: null,
    autoIncrement: true
  }, type, meta) ;
  return column;
}

NotNullColumn = _ fieldName:ObjectName _ type:Type _ NotToken _ NullToken _ meta:( Comment / "" ) _ ( "," / "" ) __ {
  var zeroValue = null;
  switch(type["type"]) {
    case "varchar":
      zeroValue = "";
      break;
    case "int":
    case "tinyint":
      zeroValue = 0;
      break;
    case "date":
    case "datetime":
      zeroValue = "CURRENT_TIMESTAMP"; // Currently use CURRENT_TIMESTAMP
      break;
  }
  var column = Object.assign({
    name: fieldName,
    default: zeroValue,
    autoIncrement: false,
  }, type, meta);
  return column;
}


NullColumn = _ fieldName:ObjectName _ type:Type _ (
  NullToken
  / DefaultToken _ NullToken
) _ meta:( Comment / "" ) _ ( "," / "" ) __ {
  var column = Object.assign({
    name: fieldName,
    type: type,
    default: null,
    autoIncrement: false
  }, type, meta);
  return column;
}

PrimaryKey
  = token:(PrimaryToken _ KeyToken) _ "(" head:ObjectName tail:( __ "," __  ObjectName)*  ")" ( "," / "" ) __ {
      var rest = flattenParams(head, tail);
      var pk = {
        type: "pk",
        keys: rest
      };
      return pk;
  }

Index
  = IndexToken _ identifier:ObjectName _ "(" head:ObjectName tail:( __ "," __  ObjectName)* _ ( AscToken / DescToken / "" ) ")" ( "," / "" ) __ {
      return genIndex(identifier, head, tail, false);
  }
  
Key
  = KeyToken _ identifier:ObjectName _ "(" head:ObjectName tail:( __ "," __  ObjectName)* _ ( AscToken / DescToken / "" ) ")" ( "," / "" ) __ {
    return genIndex(identifier, head, tail, false);
  }
  
UniqueIndex
  = UniqueToken _ IndexToken _ identifier:ObjectName _ "(" head:ObjectName tail:( __ "," __  ObjectName)* _ ( AscToken / DescToken / "" ) ")" ( "," / "" ) __ {
    return genIndex(identifier, head, tail, true);
  }

Constraint
  = ConstraintToken _ name:ObjectName _ 
  ForeignToken _ KeyToken _ "(" ihead:ObjectName itail:( __ "," __  ObjectName)* ")" _
  ReferencesToken _ fk:ObjectName _ "(" rhead:ObjectName rtail:( __ "," __  ObjectName)* ")" _
  ( OnToken _ DeleteToken _ ForeignKeyOnAction / "" ) _
  ( OnToken _ UpdateToken _ ForeignKeyOnAction ( "," / "" ) / "" ) __ {
    var identifiers = flattenParams(ihead, itail);
    var refs = flattenParams(rhead, rtail);
    return {
      type: "constraint",
      name: name,
      keys: identifiers,
      refTable: fk,
      refKeys: refs
    };
  }

ForeignKeyOnAction
  = NoToken _ ActionToken
  / CascadeToken
  / SetToken _ NullToken
  / ""

// Tokens ------------------------------

SetToken = ( "SET" / "set" ) 
CreateToken =  ( "CREATE" / "create" )
RoleToken = ( "ROLE" / "role" )
DomainToken = ( "DOMAIN" / "domain" )
TypeToken = ( "TYPE" / "type" )
TranslationToken = ( "TRANSLATION" / "translation" )
ModuleToken = ( "MODULE" / "module" )
ProcedureToken = ( "PROCEDURE" / "procedure" )
FunctionToken = ( "FUNCTION" / "function" )
MethodToken = ( "METHOD" / "method" )
SpecificToken = ( "SPECIFIC" / "specific" ) 
AlterToken = ( "ALTER" / "alter" )
DropToken = ( "DROP" / "drop" )
TruncateToken = ( "TRUNCATE" / "truncate" ) 
StartToken = ( "START" / "start" )
TransactionToken = ( "TRANSACTION" / "transaction" )
CommitToken = ( "COMMIT" / "commit" )
UseToken = ( "USE" / "use" ) 
DelimiterToken = ( "DELIMITER" / "delimiter" )
SchemaToken = ( "SCHEMA" / "schema" ) 
DefaultToken = ( "DEFAULT" / "default" )
CharacterToken = ( "CHARACTER" / "character" )
TableToken = ( "TABLE" / "table" )
IfToken = ( "IF" / "if" )
ElseToken = ( "ELSE" / "else" )
CaseToken = ( "CASE" / "case" )
WhenToken = ( "WHEN" / "when" )
NotToken = ( "NOT" / "not" )
ExistsToken = ( "EXISTS" / "exists" )
NullToken = ( "NULL" / "null" )
PrimaryToken = ( "PRIMARY" / "primary" )
KeyToken = ( "KEY" / "key" )
UniqueToken = ( "UNIQUE" / "unique" )
IndexToken = ( "INDEX" / "index" )
ConstraintToken = ( "CONSTRAINT" / "constraint" )
ForeignToken = ( "FOREIGN" / "foreign" )
ReferencesToken = ( "REFERENCES" / "references" )
AscToken = ( "ASC" / "asc" )
DescToken = ( "DESC" / "desc" )
AutoIncrementToken = ( "AUTO_INCREMENT" / "auto_increment" )
EngineToken = ( "ENGINE" / "engine" )
InsertToken = ( "INSERT" / "insert" )
IntoToken = ( "INTO" / "into" )
SelectToken = ( "SELECT" / "select" )
UpdateToken = ( "UPDATE" / "update" )
DeleteToken = ( "DELETE" / "delete" )
BeginToken = ( "BEGIN" / "begin" )
EndToken = ( "END" / "end" )
JoinToken = ( "JOIN" / "join" )
LeftToken = ( "LEFT" / "left" )
RightToken = ( "RIGHT" / "right" )
InnerToken = ( "INNER" / "inner" )
OnToken = ( "ON" / "on" )
WhereToken = ( "WHERE" / "where" )
InToken = ( "IN" / "in" ) 
TriggerToken = ( "TRIGGER" / "trigger" )
DefinerToken = ( "DEFINER" / "definer" )
NoToken = ( "NO" / "no" ) 
ActionToken = ( "ACTION" / "action" ) 
CharsetToken = ( "CHARSET" / "charset" ) 
CommentToken = ( "COMMENT" / "comment" ) 
VarToken = ("@") 
BeforeToken = ( "BEFORE" / "before" ) 
AfterToken = ( "AFTER" / "after" ) 
RestrictToken = ( "RESTRICT" / "restrict" )
CascadeToken = ( "CASCADE" / "cascade" )

// Types ------------------------------

Type "types"
  = Int
  / TinyInt
  / VarChar
  / DateTime
  / Date

Int = type:( "INT" / "int" ) _ length:Length _ sign:Sign {
  return genNumberType(type, length, sign);
}
TinyInt = type:( "TINYINT" / "tinyint" ) _ length:Length _ sign:Sign {
  return genNumberType(type, length, sign);
}
VarChar = type:( "VARCHAR" / "varchar" ) _ length:Length {
  return genStringType(type, length);
}
Date = type:( "DATE" / "date" ) {
  return {
    type: type.toLowerCase()
  }
}
DateTime = type:( "DATETIME" / "datetime" ) {
  return {
    type: type.toLowerCase()
  }
}

// TypeMeta ------------------------------

Length "length of value" = ( "(" length:integer+ ")" / "" ) { return length === "" ? 0 : length; }
Sign "signed/unsigned" = sign:( "UNSIGNED" / "unsigned" / "" ) { return sign === "" ? "signed" : "unsigned"; }

// Indentifiers ------------------------------
ObjectName "identifier" = name:( "`" regularIdentifier "`" / regularIdentifier ) {
  var objectName = Array.isArray(name) ? name.join("").replace(/`/g, "").split(",").join("") : name.replace(/`/g, "").split(",").join("");
  return objectName;
}
TableName "table name" = identifier:( ObjectName "." ObjectName / ObjectName ) {
  var ret = Array.isArray(identifier) ? {
    dbName: identifier[0],
    tableName: identifier[2]
  } : { dbName: "", tableName: identifier }
  return ret;
}

// Variables

//// Engines ------------------------------
engines = ("InnoDB" / "MyISAM")

//// Charests ------------------------------
charsets = ("utf8")

// Utilities ------------------------------

EOS "end of statement"
  = __ ";"
  / __ "$$"
  / _ SingleLineComment? LineTerminatorSequence
  / _ &")"
  / __ EOF

EOF
  = !.

__
  = ( (WhiteSpace / LineTerminatorSequence / Comment / MultiLineDelimiter / MultiLineTransaction)* ) { return null; }

_
  = ( (
  WhiteSpace
  / MultiLineCommentNoLineTerminator
  / MultiLineDelimiterNoLineTerminator
  / MultiLineTransactionNoLineTerminator)* ) { return null; }

WhiteSpace "whitespace"
  = 
  ws:("\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"
  / Zs)

// Separator, Space
Zs = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"
  
CommentOut "comment out"
  = comments:( MultiLineComment
  / SingleLineComment ) {
    return null;
  }

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator "open mulit-line comment"
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"

SingleLineComment "single-line comment"
  = "--" (!LineTerminator SourceCharacter)*

DelimiterStart = DelimiterToken _ "$$"
DelimiterEnd = DelimiterToken _ ";"

MultiLineDelimiter
  = DelimiterStart (!DelimiterEnd SourceCharacter)* DelimiterEnd
  
MultiLineDelimiterNoLineTerminator "open mulit-line delimiter"
  = DelimiterStart (!(DelimiterEnd / LineTerminator) SourceCharacter)* DelimiterEnd

StartTransaction = StartToken _ TransactionToken __ EOS
Commit = CommitToken __ EOS

MultiLineTransaction
  = StartTransaction (!Commit SourceCharacter)* Commit

MultiLineTransactionNoLineTerminator "open mulit-line transaction"
  = StartTransaction (!(Commit / LineTerminator) SourceCharacter)* Commit

SourceCharacter
  = .

integer "integer"
  = [0-9]

letter "letter"
  = [a-zA-Z]

defaultValue "defaults"
  = d:(anyCharacter / integer+ / "") {
  	var val = null;
    if (Array.isArray(d)) {
      val = flatten(d);
    } else if (typeof d === "string") {
      val = d.replace(/'/g, "");
    } else {
      throw new Error("Unexpected type found while processing defaultValue.");
    }
    return val;
  }

anyCharacter "any characters"
  = chars:("'" (!"'" SourceCharacter)* "'") {
	var flattened = flatten(chars);
    return flattened.join("");
  }

// Any does not consume any input
any "any"
  = ((!EOS SourceCharacter)* EOS) { return null; }

regularIdentifier "regular Identifier"
  = [a-zA-Z_]+

wl = "(" { return null; }
wr = ")" { return null; }